Первый баг: буфер в стеке 28 символов, поэтому, при вводе большего числа символов, в 29-ом и 30-ом будут лежать (соответствуя little ending) коды, формирующие номер last symbol, если ввести любой символ с кодом меньше 7Ah(122d), а затем ввести символ с кодом 01(ввод при помощи ctrl+a), то там будет лежать число, которое в последствие окажется в bx и будет сравнено с началом буфера пароля (строки 45-46 и 57-58 в Pasart.asm), так можно обойти прыжок на проверку строк, сразу переходя к выводу сообщения о правильности пароля

Второй баг: Также основана на переполнении буфера, только в этот раз нужно ввести 60 любых символов, а затем shift+m и shift+a (4D 01 в ascii table), что сопадает с адресом вывода сообщения о верном пароле(60 строка в Pasart.asm), потому, испольняя команду ret(70 строка в Pasart.asm) после вывода сообщения о неверном пароле, вместо возвращения в main вернётся к выводу нужной нам части кода, итоговый вывод будет содержать сообщения о неверном и верном пароле, но так как был выполнен участок кода с выводом сообщения об успешном вводе пароля, программу можно считать взломанной

Совершенно другой вариант сломать проверку пароля: воспользоваться моей программой Crack.c, которая находит jne в бинарном файле и заменяет на je, благодаря чему при вводе неправильного пароля будет выводиться сообщение о том, что он правильный (главное - случайно не ввести прасильный пароль :)    )

Программа FMATHEW.ASM была создана для моего напарника, в ней допущено две уязвимости, позволяющие при помощи перполнения буфера заставить мою программу сказать, что пароль верный. Советую попробовать взломать FMATHEW.COM, в ней есть интересные находки для хакерского обучения!
